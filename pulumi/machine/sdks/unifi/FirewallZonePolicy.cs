// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Unifi
{
    [UnifiResourceType("unifi:index/firewallZonePolicy:FirewallZonePolicy")]
    public partial class FirewallZonePolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Output("autoAllowReturnTraffic")]
        public Output<bool> AutoAllowReturnTraffic { get; private set; } = null!;

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Output("connectionStateType")]
        public Output<string> ConnectionStateType { get; private set; } = null!;

        /// <summary>
        /// Connection states to match when `connection_state_type` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        [Output("connectionStates")]
        public Output<ImmutableArray<string>> ConnectionStates { get; private set; } = null!;

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Output("destination")]
        public Output<Outputs.FirewallZonePolicyDestination> Destination { get; private set; } = null!;

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Output("index")]
        public Output<double> Index { get; private set; } = null!;

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Output("ipVersion")]
        public Output<string> IpVersion { get; private set; } = null!;

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Output("logging")]
        public Output<bool> Logging { get; private set; } = null!;

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Output("matchIpSecType")]
        public Output<string?> MatchIpSecType { get; private set; } = null!;

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Output("matchOppositeProtocol")]
        public Output<bool> MatchOppositeProtocol { get; private set; } = null!;

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `all`, `tcp_udp`, `tcp`, `udp`, etc.
        /// </summary>
        [Output("protocol")]
        public Output<string> Protocol { get; private set; } = null!;

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Output("schedule")]
        public Output<Outputs.FirewallZonePolicySchedule> Schedule { get; private set; } = null!;

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Output("site")]
        public Output<string> Site { get; private set; } = null!;

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Output("source")]
        public Output<Outputs.FirewallZonePolicySource> Source { get; private set; } = null!;


        /// <summary>
        /// Create a FirewallZonePolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public FirewallZonePolicy(string name, FirewallZonePolicyArgs args, CustomResourceOptions? options = null)
            : base("unifi:index/firewallZonePolicy:FirewallZonePolicy", name, args ?? new FirewallZonePolicyArgs(), MakeResourceOptions(options, ""), Utilities.PackageParameterization())
        {
        }

        private FirewallZonePolicy(string name, Input<string> id, FirewallZonePolicyState? state = null, CustomResourceOptions? options = null)
            : base("unifi:index/firewallZonePolicy:FirewallZonePolicy", name, state, MakeResourceOptions(options, id), Utilities.PackageParameterization())
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing FirewallZonePolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static FirewallZonePolicy Get(string name, Input<string> id, FirewallZonePolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new FirewallZonePolicy(name, id, state, options);
        }
    }

    public sealed class FirewallZonePolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Input("action", required: true)]
        public Input<string> Action { get; set; } = null!;

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Input("autoAllowReturnTraffic")]
        public Input<bool>? AutoAllowReturnTraffic { get; set; }

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Input("connectionStateType")]
        public Input<string>? ConnectionStateType { get; set; }

        [Input("connectionStates")]
        private InputList<string>? _connectionStates;

        /// <summary>
        /// Connection states to match when `connection_state_type` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        public InputList<string> ConnectionStates
        {
            get => _connectionStates ?? (_connectionStates = new InputList<string>());
            set => _connectionStates = value;
        }

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Input("destination", required: true)]
        public Input<Inputs.FirewallZonePolicyDestinationArgs> Destination { get; set; } = null!;

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Input("index")]
        public Input<double>? Index { get; set; }

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Input("ipVersion")]
        public Input<string>? IpVersion { get; set; }

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Input("matchIpSecType")]
        public Input<string>? MatchIpSecType { get; set; }

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Input("matchOppositeProtocol")]
        public Input<bool>? MatchOppositeProtocol { get; set; }

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `all`, `tcp_udp`, `tcp`, `udp`, etc.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.FirewallZonePolicyScheduleArgs>? Schedule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Input("source", required: true)]
        public Input<Inputs.FirewallZonePolicySourceArgs> Source { get; set; } = null!;

        public FirewallZonePolicyArgs()
        {
        }
        public static new FirewallZonePolicyArgs Empty => new FirewallZonePolicyArgs();
    }

    public sealed class FirewallZonePolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Determines which action to take on matching traffic. Must be one of `BLOCK`, `ALLOW`, or `REJECT`.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Creates a built-in policy for the opposite Zone Pair to automatically allow the return traffic. If disabled, return traffic must be manually allowed
        /// </summary>
        [Input("autoAllowReturnTraffic")]
        public Input<bool>? AutoAllowReturnTraffic { get; set; }

        /// <summary>
        /// Optionally match on a firewall connection state such as traffic associated with an already existing connection. Valid values are `ALL`, `RESPOND_ONLY`, or `CUSTOM`.
        /// </summary>
        [Input("connectionStateType")]
        public Input<string>? ConnectionStateType { get; set; }

        [Input("connectionStates")]
        private InputList<string>? _connectionStates;

        /// <summary>
        /// Connection states to match when `connection_state_type` is `CUSTOM`. Valid values include `ESTABLISHED`, `NEW`, `RELATED`, and `INVALID`.
        /// </summary>
        public InputList<string> ConnectionStates
        {
            get => _connectionStates ?? (_connectionStates = new InputList<string>());
            set => _connectionStates = value;
        }

        /// <summary>
        /// Description of the firewall zone policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The zone matching the destination of the traffic. Optionally match on a specific destination inside the zone.
        /// </summary>
        [Input("destination")]
        public Input<Inputs.FirewallZonePolicyDestinationGetArgs>? Destination { get; set; }

        /// <summary>
        /// Enable the policy
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Priority index for the policy.
        /// </summary>
        [Input("index")]
        public Input<double>? Index { get; set; }

        /// <summary>
        /// Optionally match on only IPv4 or IPv6. Valid values are `BOTH`, `IPV4`, or `IPV6`.
        /// </summary>
        [Input("ipVersion")]
        public Input<string>? IpVersion { get; set; }

        /// <summary>
        /// Enable to generate syslog entries when traffic is matched.
        /// </summary>
        [Input("logging")]
        public Input<bool>? Logging { get; set; }

        /// <summary>
        /// Optionally match on traffic encrypted by IPsec. This is typically used for Ipsec Policy-Based VPNs. Valid values are `MATCH_IP_SEC` or `MATCH_NON_IP_SEC`.
        /// </summary>
        [Input("matchIpSecType")]
        public Input<string>? MatchIpSecType { get; set; }

        /// <summary>
        /// Whether to match the opposite protocol.
        /// </summary>
        [Input("matchOppositeProtocol")]
        public Input<bool>? MatchOppositeProtocol { get; set; }

        /// <summary>
        /// The name of the firewall zone policy.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Optionally match a specific protocol. Valid values include: `all`, `tcp_udp`, `tcp`, `udp`, etc.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Enforce this policy at specific times.
        /// </summary>
        [Input("schedule")]
        public Input<Inputs.FirewallZonePolicyScheduleGetArgs>? Schedule { get; set; }

        /// <summary>
        /// The name of the UniFi site where this resource should be applied. If not specified, the default site will be used.
        /// </summary>
        [Input("site")]
        public Input<string>? Site { get; set; }

        /// <summary>
        /// The zone matching the source of the traffic. Optionally match on a specific source inside the zone.
        /// </summary>
        [Input("source")]
        public Input<Inputs.FirewallZonePolicySourceGetArgs>? Source { get; set; }

        public FirewallZonePolicyState()
        {
        }
        public static new FirewallZonePolicyState Empty => new FirewallZonePolicyState();
    }
}
