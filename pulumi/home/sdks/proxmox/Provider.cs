// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Proxmox
{
    /// <summary>
    /// The provider type for the proxmox package. By default, resources use package-wide configuration
    /// settings, however an explicit `Provider` instance may be created and passed during resource
    /// construction to achieve fine-grained programmatic control over provider settings. See the
    /// [documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.
    /// </summary>
    [ProxmoxResourceType("pulumi:providers:proxmox")]
    public partial class Provider : global::Pulumi.ProviderResource
    {
        /// <summary>
        /// API TokenID e.g. root@pam!mytesttoken
        /// </summary>
        [Output("pmApiTokenId")]
        public Output<string?> PmApiTokenId { get; private set; } = null!;

        /// <summary>
        /// The secret uuid corresponding to a TokenID
        /// </summary>
        [Output("pmApiTokenSecret")]
        public Output<string?> PmApiTokenSecret { get; private set; } = null!;

        /// <summary>
        /// https://host.fqdn:8006/api2/json
        /// </summary>
        [Output("pmApiUrl")]
        public Output<string?> PmApiUrl { get; private set; } = null!;

        /// <summary>
        /// Set custom http headers e.g. Key,Value,Key1,Value1
        /// </summary>
        [Output("pmHttpHeaders")]
        public Output<string?> PmHttpHeaders { get; private set; } = null!;

        /// <summary>
        /// Write logs to this specific file
        /// </summary>
        [Output("pmLogFile")]
        public Output<string?> PmLogFile { get; private set; } = null!;

        /// <summary>
        /// OTP 2FA code (if required)
        /// </summary>
        [Output("pmOtp")]
        public Output<string?> PmOtp { get; private set; } = null!;

        /// <summary>
        /// Password to authenticate into proxmox
        /// </summary>
        [Output("pmPassword")]
        public Output<string?> PmPassword { get; private set; } = null!;

        /// <summary>
        /// Proxy Server passed to Api client(useful for debugging). Syntax: http://proxy:port
        /// </summary>
        [Output("pmProxyServer")]
        public Output<string?> PmProxyServer { get; private set; } = null!;

        /// <summary>
        /// Username e.g. myuser or myuser@pam
        /// </summary>
        [Output("pmUser")]
        public Output<string?> PmUser { get; private set; } = null!;


        /// <summary>
        /// Create a Provider resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Provider(string name, ProviderArgs? args = null, CustomResourceOptions? options = null)
            : base("proxmox", name, args ?? new ProviderArgs(), MakeResourceOptions(options, ""), Utilities.PackageParameterization())
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "pmApiTokenSecret",
                    "pmPassword",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }

        /// <summary>
        /// This function returns a Terraform config object with terraform-namecased keys,to be used with the Terraform Module Provider.
        /// </summary>
        public global::Pulumi.Output<ImmutableDictionary<string, object>> TerraformConfig()
            => global::Pulumi.Deployment.Instance.Call<ProviderTerraformConfigResult>("pulumi:providers:proxmox/terraformConfig", CallArgs.Empty, this, null, Utilities.PackageParameterization()).Apply(v => v.Result);
    }

    public sealed class ProviderArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// API TokenID e.g. root@pam!mytesttoken
        /// </summary>
        [Input("pmApiTokenId")]
        public Input<string>? PmApiTokenId { get; set; }

        [Input("pmApiTokenSecret")]
        private Input<string>? _pmApiTokenSecret;

        /// <summary>
        /// The secret uuid corresponding to a TokenID
        /// </summary>
        public Input<string>? PmApiTokenSecret
        {
            get => _pmApiTokenSecret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _pmApiTokenSecret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// https://host.fqdn:8006/api2/json
        /// </summary>
        [Input("pmApiUrl")]
        public Input<string>? PmApiUrl { get; set; }

        /// <summary>
        /// By default this provider will exit if an unknown attribute is found. This is to prevent the accidential destruction of VMs or Data when something in the proxmox API has changed/updated and is not confirmed to work with this provider. Set this to true at your own risk. It may allow you to proceed in cases when the provider refuses to work, but be aware of the danger in doing so.
        /// </summary>
        [Input("pmDangerouslyIgnoreUnknownAttributes", json: true)]
        public Input<bool>? PmDangerouslyIgnoreUnknownAttributes { get; set; }

        /// <summary>
        /// Enable or disable the verbose debug output from proxmox api
        /// </summary>
        [Input("pmDebug", json: true)]
        public Input<bool>? PmDebug { get; set; }

        /// <summary>
        /// Set custom http headers e.g. Key,Value,Key1,Value1
        /// </summary>
        [Input("pmHttpHeaders")]
        public Input<string>? PmHttpHeaders { get; set; }

        /// <summary>
        /// Enable provider logging to get proxmox API logs
        /// </summary>
        [Input("pmLogEnable", json: true)]
        public Input<bool>? PmLogEnable { get; set; }

        /// <summary>
        /// Write logs to this specific file
        /// </summary>
        [Input("pmLogFile")]
        public Input<string>? PmLogFile { get; set; }

        [Input("pmLogLevels", json: true)]
        private InputMap<string>? _pmLogLevels;

        /// <summary>
        /// Configure the logging level to display; trace, debug, info, warn, etc
        /// </summary>
        public InputMap<string> PmLogLevels
        {
            get => _pmLogLevels ?? (_pmLogLevels = new InputMap<string>());
            set => _pmLogLevels = value;
        }

        /// <summary>
        /// OTP 2FA code (if required)
        /// </summary>
        [Input("pmOtp")]
        public Input<string>? PmOtp { get; set; }

        [Input("pmParallel", json: true)]
        public Input<double>? PmParallel { get; set; }

        [Input("pmPassword")]
        private Input<string>? _pmPassword;

        /// <summary>
        /// Password to authenticate into proxmox
        /// </summary>
        public Input<string>? PmPassword
        {
            get => _pmPassword;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _pmPassword = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Proxy Server passed to Api client(useful for debugging). Syntax: http://proxy:port
        /// </summary>
        [Input("pmProxyServer")]
        public Input<string>? PmProxyServer { get; set; }

        /// <summary>
        /// How many seconds to wait for operations for both provider and api-client, default is 20m
        /// </summary>
        [Input("pmTimeout", json: true)]
        public Input<double>? PmTimeout { get; set; }

        [Input("pmTlsInsecure", json: true)]
        public Input<bool>? PmTlsInsecure { get; set; }

        /// <summary>
        /// Username e.g. myuser or myuser@pam
        /// </summary>
        [Input("pmUser")]
        public Input<string>? PmUser { get; set; }

        public ProviderArgs()
        {
        }
        public static new ProviderArgs Empty => new ProviderArgs();
    }

    /// <summary>
    /// The results of the <see cref="Provider.TerraformConfig"/> method.
    /// </summary>
    [OutputType]
    internal sealed class ProviderTerraformConfigResult
    {
        public readonly ImmutableDictionary<string, object> Result;

        [OutputConstructor]
        private ProviderTerraformConfigResult(ImmutableDictionary<string, object> result)
        {
            Result = result;
        }
    }
}
